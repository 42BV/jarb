package org.jarbframework.violation.integration;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.HashMap;
import java.util.Map;

import javax.sql.DataSource;

import org.jarbframework.violation.DatabaseConstraintExceptionTranslator;
import org.jarbframework.violation.UniqueKeyViolationException;
import org.jarbframework.violation.domain.LicenseNumberAlreadyExistsException;
import org.jarbframework.violation.domain.LicenseNumberAlreadyExistsExceptionFactory;
import org.jarbframework.violation.factory.DatabaseConstraintExceptionFactory;
import org.jarbframework.violation.factory.SimpleConstraintExceptionFactory;
import org.jarbframework.violation.factory.mapping.ConstraintViolationMatcher;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Factory should produce functional exception translators.
 * 
 * @author Jeroen van Schagen
 * @since 17-05-2011
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "classpath:hsql-context.xml" })
public class ConstraintViolationExceptionTranslatorFactoryBeanTest {
    private static final String UNIQUE_KEY_EXCEPTION_MESSAGE = "integrity constraint violation: unique constraint or index violation; uk_cars_license table: cars";

    @Autowired
    private DataSource dataSource;

    private ConstraintViolationExceptionTranslatorFactoryBean factory;

    @Before
    public void setUp() throws Exception {
        factory = new ConstraintViolationExceptionTranslatorFactoryBean();
        factory.setDataSource(dataSource);
    }

    /**
     * Ensure that the translator, generated by this factory, recognizes HSQL database
     * exceptions and thus is configured correctly.
     */
    @Test
    public void testTranslator() throws Exception {
        factory.setDefaultExceptionFactory(new SimpleConstraintExceptionFactory());
        DatabaseConstraintExceptionTranslator translator = factory.getObject();
        RuntimeException hsqlException = new RuntimeException(UNIQUE_KEY_EXCEPTION_MESSAGE);
        Throwable resultException = translator.translateExceptionIfPossible(hsqlException);
        assertTrue(resultException instanceof UniqueKeyViolationException);
        assertEquals(translator, factory.getObject()); // Also ensure the translator is singleton
    }

    /**
     * Our license number already exists exception can also be thrown by a custom factory.
     */
    @Test
    public void testCustomFactoryIsRegistered() throws Exception {
        Map<ConstraintViolationMatcher, DatabaseConstraintExceptionFactory> factories;
        factories = new HashMap<ConstraintViolationMatcher, DatabaseConstraintExceptionFactory>();
        DatabaseConstraintExceptionFactory exceptionFactory = new LicenseNumberAlreadyExistsExceptionFactory();
        factories.put(new ConstraintViolationMatcher("uk_cars_license"), exceptionFactory);
        factory.setCustomExceptionFactories(factories);
        DatabaseConstraintExceptionTranslator translator = factory.getObject();
        RuntimeException hsqlException = new RuntimeException(UNIQUE_KEY_EXCEPTION_MESSAGE);
        Throwable resultException = translator.translateExceptionIfPossible(hsqlException);
        assertTrue(resultException instanceof LicenseNumberAlreadyExistsException);
        assertEquals(exceptionFactory, ((LicenseNumberAlreadyExistsException) resultException).getExceptionFactory());
    }

    @Test
    public void testGetObjectType() {
        assertEquals(DatabaseConstraintExceptionTranslator.class, factory.getObjectType());
    }

}
